let dataStore = {
  masterPrivateKey: '', // KyP8beDgjXJSvjNRSLic2xvcep9AP9n1UKwC2CwmXb3Y5sSNspyr
  masterPublicKey: '',
  callbacks: [],
  tokensStatus: false,
  supportedTokens: ['XCP', 'TATIANACOIN'],
  enabledTokens: [],
  addresses: {
    '1ap9c9md98tymqu3aeppqw23OT1': {currentBalance: 1.5, isUsed: true},
    '1wp9cnm5p8xym0u3aepNAYECOTN': {currentBalance: 3.1, isUsed: true},
    '1pq3iwq5p889m1u4aepUA9271Tz': {currentBalance: 0, isUsed: false}
  },
  transactions: [
    { // 00
      abcWalletTransaction: '',
      metadata: {
        payeeName: 'Satoshi Nakamoto',
        category: 'Block Reward',
        notes: 'Some notes about this transaction',
        amountFiat: 50000,
        bizId: undefined,
        miscJson: ''
      },
      txid: '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b',
      date: '2009-01-03 18:15:05',
      blockHeight: 0,
      amountSatoshi: 0,
      providerFee: 0,
      networkFee: 0,
      runningBalance: 50,
      signedTx: true,
      otherParams: {
        isReplaceByFee: false,
        isDoubleSpend: false,
        inputOutputList: []
      }
    },
    { // 01
      abcWalletTransaction: '',
      metadata: {
        payeeName: 'Satoshi Nakamoto',
        category: 'Tips',
        notes: 'Thanks for the free parking',
        amountFiat: 1,
        bizId: undefined,
        miscJson: ''
      },
      txid: '3387418aaddb4927209c5032f515aa442a6587d6e54677f08a03b8fa7789e688',
      date: '2009-01-03 18:15:05',
      blockHeight: 0,
      amountSatoshi: 0,
      providerFee: 0,
      networkFee: 0,
      runningBalance: 50,
      signedTx: true,
      otherParams: {
        isReplaceByFee: false,
        isDoubleSpend: false,
        inputOutputList: []
      }
    },
    { // 02
      abcWalletTransaction: '',
      metadata: {
        payeeName: 'Satoshi Nakamoto',
        category: 'Tips',
        notes: 'Thanks for the free parking',
        amountFiat: 1,
        bizId: undefined,
        miscJson: ''
      },
      txid: '4574958d135e66a53abf9c61950aba340e9e140be50efeea9456aa9f92bf40b5',
      date: '2009-01-03 18:15:05',
      blockHeight: 0,
      amountSatoshi: 0,
      providerFee: 0,
      networkFee: 0,
      runningBalance: 50,
      signedTx: true,
      otherParams: {
        isReplaceByFee: false,
        isDoubleSpend: false,
        inputOutputList: []
      }
    },
    { // 03
      abcWalletTransaction: '',
      metadata: {
        payeeName: 'Satoshi Nakamoto',
        category: 'Tips',
        notes: 'Thanks for the free parking',
        amountFiat: 1,
        bizId: undefined,
        miscJson: ''
      },
      txid: '8b960c87f9f1a6e6910e214fcf5f9c69b60319ba58a39c61f299548412f5a1c6',
      date: '2009-01-03 18:15:05',
      blockHeight: 0,
      amountSatoshi: 0,
      providerFee: 0,
      networkFee: 0,
      runningBalance: 50,
      signedTx: true,
      otherParams: {
        isReplaceByFee: false,
        isDoubleSpend: false,
        inputOutputList: []
      }
    },
    { // 04
      abcWalletTransaction: '',
      metadata: {
        payeeName: 'Satoshi Nakamoto',
        category: 'Tips',
        notes: 'Thanks for the free parking',
        amountFiat: 1,
        bizId: undefined,
        miscJson: ''
      },
      txid: 'f1db8d2c1ed576bc22f73016b3cbc1496797c442c7df9bbbe7649df2460c78aa',
      date: '2009-01-03 18:15:05',
      blockHeight: 0,
      amountSatoshi: 0,
      providerFee: 0,
      networkFee: 0,
      runningBalance: 50,
      signedTx: true,
      otherParams: {
        isReplaceByFee: false,
        isDoubleSpend: false,
        inputOutputList: []
      }
    },
    { // 05
      abcWalletTransaction: '',
      metadata: {
        payeeName: 'Satoshi Nakamoto',
        category: 'Tips',
        notes: 'Thanks for the free parking',
        amountFiat: 1,
        bizId: undefined,
        miscJson: ''
      },
      txid: '60ff2dfdf67917040139903a0141f7525a7d152365b371b35fd1cf83f1d7f704',
      date: '2009-01-03 18:15:05',
      blockHeight: 0,
      amountSatoshi: 0,
      providerFee: 0,
      networkFee: 0,
      runningBalance: 50,
      signedTx: true,
      otherParams: {
        isReplaceByFee: false,
        isDoubleSpend: false,
        inputOutputList: []
      }
    },
    { // 06
      abcWalletTransaction: '',
      metadata: {
        payeeName: 'Satoshi Nakamoto',
        category: 'Tips',
        notes: 'Thanks for the free parking',
        amountFiat: 1,
        bizId: undefined,
        miscJson: ''
      },
      txid: '8f6b63012753005236b1b76e4884e4dee7415e05ab96604d353001662cde6b53',
      date: '2009-01-03 18:15:05',
      blockHeight: 0,
      amountSatoshi: 0,
      providerFee: 0,
      networkFee: 0,
      runningBalance: 50,
      signedTx: true,
      otherParams: {
        isReplaceByFee: false,
        isDoubleSpend: false,
        inputOutputList: []
      }
    },
    { // 07
      abcWalletTransaction: '',
      metadata: {
        payeeName: 'Satoshi Nakamoto',
        category: 'Tips',
        notes: 'Thanks for the free parking',
        amountFiat: 1,
        bizId: undefined,
        miscJson: ''
      },
      txid: '495167f5b9d55519717cb171208a98ffd347410169f258b598b1b65447d8e078',
      date: '2009-01-03 18:15:05',
      blockHeight: 0,
      amountSatoshi: 0,
      providerFee: 0,
      networkFee: 0,
      runningBalance: 50,
      signedTx: true,
      otherParams: {
        isReplaceByFee: false,
        isDoubleSpend: false,
        inputOutputList: []
      }
    },
    { // 08
      abcWalletTransaction: '',
      metadata: {
        payeeName: 'Satoshi Nakamoto',
        category: 'Tips',
        notes: 'Thanks for the free parking',
        amountFiat: 1,
        bizId: undefined,
        miscJson: ''
      },
      txid: '1b703ca32b2da08cf896081a96c48f6433641e2c7d805fd170a31b0cbfb900df',
      date: '2009-01-03 18:15:05',
      blockHeight: 0,
      amountSatoshi: 0,
      providerFee: 0,
      networkFee: 0,
      runningBalance: 50,
      signedTx: true,
      otherParams: {
        isReplaceByFee: false,
        isDoubleSpend: false,
        inputOutputList: []
      }
    }
  ],

  getInfo: { // Details of supported currency
    currencyCode: 'BTC', // The 3 character code for the currency
    denominations: [ // An array of Objects of the possible denominations for this currency
      {
        name: 'bits', // The human readable string to describe the denomination
        multiplier: 100, // The value to multiply the smallest unit of currency to get to the denomination
        symbol: 'ƀ' // The human readable 1-3 character symbol of the currency, e.g “Ƀ”
      },
      {
        name: 'mBTC',
        multiplier: 100000,
        symbol: 'mɃ'
      },
      {
        name: 'BTC',
        multiplier: 100000000,
        symbol: 'Ƀ'
      }
    ],
    symbolImage: 'qq/2iuhfiu1/3iufhlq249r8yq34tiuhq4giuhaiwughiuaergih/rg', // Base64 encoded png or jpg image of the currency symbol (optional)
    metaTokens: [ // Array of objects describing the supported metatokens
      {
        currencyCode: 'XCP',
        denominations: [{
          name: 'XCP',
          multiplier: 1
        }],
        symbolImage: 'fe/3fthfiu1/3iufhlq249r8yq34tiuhqggiuhaiwughiuaergih/ef'
      },
      {
        currencyCode: 'TATIANACOIN',
        denominations: [{
          name: 'TATIANACOIN',
          multiplier: 1
        }],
        symbolImage: 'qe/3fthfi2fg1/3iufhlq249r8yq34tiuhqggiuhaiwughiuaergih/ef'
      }
    ]
  },

  init: function (options = {}, callbacks = {}) {
    let {
      masterPrivateKey,
      masterPublicKey
    } = options
    this.setMasterPrivateKey(masterPrivateKey)
    this.setMasterPublicKey(masterPublicKey)
    this.setCallbacks(callbacks)

    return true
  },

  setMasterPrivateKey: function (masterPrivateKey) {
    this.masterPrivateKey = masterPrivateKey

    return true
  },

  setMasterPublicKey: function (masterPublicKey) {
    this.masterPublicKey = masterPublicKey

    return true
  },

  enableTokens: function (options = {}) {
    let {
      abcTxLibAccess,
      tokens
    } = options
    let desiredTokens = tokens.filter((token) => {
      return this.supportedTokens.includes(token)
    })

    this.enabledTokens = this.enabledTokens.concat(desiredTokens).filter((elem, index, self) => {
      return index === self.indexOf(elem)
    })
    this.tokensStatus = true

    return this.enabledTokens
  },

  getTokensStatus: function () {
    return this.tokensStatus
  },

  setCallbacks: function (callbacks) {
    this.callbacks = callbacks

    return true
  },

  getCallbacks: function () {
    return this.callbacks
  },

  getBalance: function (options) {
    let {
      abcTxLibGetBalance,
      currencyCode
    } = options

    let addresses = Object.values(this.addresses)
    let balance =
      addresses.reduce((acc, address) => {
        return acc + address.currentBalance
      }, 0)

    return balance
  },

  getNumTransactions: function (options = {}) {
    let {
      abcTxLibGetBalance,
      currencyCode
    } = options

    let transactions = this.transactions
    let numTransactions = transactions.length

    return numTransactions
  },

  getTransactions: function (options = {}) {
    let {
      abcTxLibAccess,
      currencyCode,
      startIndex, // The starting index into the list of transactions. 0 specifies the newest transaction
      numEntries // The number of entries to return. If there aren’t enough transactions to return numEntries, then the TxLib should return the maximum possible
    } = options
    let endIndex = (startIndex + numEntries) || undefined // if user doesn't supply a startIndex or numEntries, return undefined instead of NaN

    let transactions = this.transactions.slice(startIndex, endIndex)

    return transactions
  },

  getFreshAddress: function (options = {}) {
    let {
      abcTxLibAccess,
      currencyCode
    } = options

    let addressList = Object.entries(this.addresses)
    let address = addressList.find((address) => {
      return address[1].isUsed === false
    })

    return address[0]
  },

  isAddressUsed: function (options = {}) {
    let {
      abcTxLibAccess,
      address,
      currencyCode
    } = options

    let targetAddress = this.addresses[address]
    let isUsed = targetAddress.isUsed

    return isUsed
  },

  addGapLimitAddresses: function (options = {}) {
    let {
      abcTxLibAccess,
      addresses,
      currencyCode
    } = options

    return true
  }
}

module.exports = dataStore
